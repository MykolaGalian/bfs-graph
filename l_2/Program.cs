using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;



namespace l_2
{    //  BFS - находит все кратчайшие пути во все узлы из исходного узла (невзвешеный граф - мин. количество ребер),
     // затем по указаному целевому узлу строится найденый ранее путь (если несколько путей одной длины, то печатает альтернативные узлы с большим номером)
     // BFS - все посещенные узлы помечаются (черные), и второй раз уже не посещаются

    public class V  // класс описывающий узел
    {
        public int Number_Node { get; set; }  // номер узла

        public V Next { get; set; }  // один - узел смежный с текущим (переменная класса) - при первичной инициализации = null
        public V Parent { get; set; }  //родительский узел - для отслеживания направления от исходного узла (переменная класса)- при первичной инициализации = null

        public char Color { get; set; }    //цвет (белый - не обработаный, серый - в работе, черный - обработаный)

        public V(int val)  // конструктор
        {
            Number_Node = val;          
            Color = 'W';
        }                  
    }

    public class BreadthFirstSearch  // класс реализующий методы BFS
    {
        public V[] adjList;  // объявляем массив узлов (объекты класса V)  - для каждого узла будет формироваться "список" смежности 

        public BreadthFirstSearch(int totalVertix) // конструктор для класса (принимает количество узлов)
        {
            adjList = new V[totalVertix];  // создаем массив из заданого количества объектов класса V (узлов), т.е. 
                                           // создаете [много] пустых ссылок на будущие объекты Класса. И все элементы этого массива пока равны null (полей нет) 
                                           //то есть экземпляры не создаются, просто выделяется набор ссылок
            for (int i = 0; i < adjList.Length; i++)
                adjList[i] = new V(i);    //инициализируем каждый элемент массива конструктором (i)- задаем номера узлам и помечаем их белым
        }


        public void AddV(int u, int v)  // метод добавляет узлы v в список смежности (adjList) узла "u"  (по информации из матрицы смежности) 
        {
            V tempU = adjList[u]; // работаем с узлом заданного номера 
                                  // проверка, имеется уже такой узел v в "списке" смежности узла "u"///////////////////////////////////////////
            while (tempU.Next != null)  // цикл работает только если поле Next для текущего узла занято (перебор уже имеющихся смежных узлов)
            {
                if (tempU.Number_Node != v) //проверка "списка" узла "u"
                    tempU = tempU.Next;   // переход к следующему узлу
                else
                    return; // если есть то выход из метода (--петля--путь из ула в узел не рассматриваем)
            }
            tempU.Next = new V(v);   // добавление нового узла v (создание нового обьекта кл. V с необходимым номером узла) 
        }                              //в --конец--- "списка" смежности узла u, если такого узла еще не было

        private void BFS(int source) // метод реализует обход графа в ширину из переданного номера узла, используем это
                                     //для указания для каждого узла родственника, начиная с исходного, для возможности восстановления пути,
                                     // и помечаем посещенные узлы, для того чтобы не посещать их второй раз
        {
            Queue<V> queue = new Queue<V>(); //инициализация очереди для элементов класса V, для учета текущих рассматриваемых узлов
            V src = adjList[source]; //src ссылается на обьекта класса V (исходный узел) 
            src.Color = 'G'; //помечаем исходный узел серым цветом
           
            src.Parent = null;  // родительских узлов нет у исходного узла (повтор)
                        
            queue.Enqueue(src); //добавляем исходный узел в конец очереди
            while (queue.Count > 0) // пока очередь не пуста 
            {
                V u = queue.Dequeue(); //удаляем рассматриваемый узел из начала очереди и возвращаем его обьекту "u" класса V.
                                      // u ссылается на обьекта класса V (текущий рассматриваемый узел в очереди)
                V v = u.Next; // v ссылается на смежный узел (из "списка" - данные из поля Next) для только что убраного из очереди узла - в начале  V v = u.Next ==> null 

                while (v != null)   // выход из цикла когда не останется смежных узлов в списке смежности 
                {
                    V mainV = adjList[v.Number_Node];  // инициализация обьекта mainV класса V  текущим узлом из списка смежности узла u
                    if (mainV.Color == 'W') //рассматриваемый узел должен быть не посещенн еще
                    {
                        mainV.Color = 'G'; //помечаем узел серым - обрабатываем узел (который пойдет в очередь)
                       
                        mainV.Parent = u; //для текущего узла указываем родителя (узел который последний удалили из очереди)

                        queue.Enqueue(mainV); //вставляем в очередь рассматриваемый текущий узел
                    }
                    v = v.Next; //присваиваем v другой узел смежный к текущему  (перебираем только список смежных узлов для узла выброшеного из очереди на предидущем шаге)
                }
                u.Color = 'B'; //после обработки узла помечаем его как черный
            }
        }
        
        private void RecPrint(V u, V v) // рекурсивный метод для распечатки  от исходного u до заданого узла v 
        {
            if (u == v)
                Console.Write(u.Number_Node+"->");
            else if (v.Parent == null)
                Console.WriteLine("Нет пути между указанными узлами");
            else
            {
                RecPrint(u, v.Parent); // рекурсивный вызов метода с исх. узлом для первого аргумента 
                                       //и родительским узлом (перебор узлов от целевого по найденым BFS родителям) для второго аргумента 
                Console.Write(v.Number_Node + "->"); // при выходе из рекурсии выводим путь
            }
        }


        public void PrintPath(int u, int v) //  u - исходный,  v - целевой узел
        {
            BFS(u); // вызов метода реализующего BFS для заданого исходного узла  
            Console.WriteLine($"Найденый кротчайший маршрут между узлами {u} и {v}:");
            RecPrint(adjList[u], adjList[v]); // распечатка пути от исходного до заданого узла 
        }

    }
    



    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Лаб.2 (вар.№3) Нахождение кратчайшего пути в невзвешенном графе между двумя заданными узлами,");
            Console.WriteLine("с помощью алгоритма поиска в ширину (BFS).");
            Console.WriteLine("Введите количество узлов графа (целое, не отрицательное):");
            int Num = Convert.ToInt32(Console.ReadLine());

            BreadthFirstSearch demo = new BreadthFirstSearch(Num); // создание обьекта класса  BreadthFirstSearch (передали количество узлов)
                                                                   // содержит методы BFS и оперирует массивом объектов класса V


            int A = 0; // вариант выбора
            Console.Write("Введите 1 (автоматическое создание графа)\n");
            Console.Write("Введите 2 (ручное создание графа)\n");
            A = Convert.ToInt32(Console.ReadLine());  
            if (A == 1) graph_auto();
            else if (A == 2) graph_manual();
                      
            

            void graph_manual()
            {
                Console.WriteLine("Введите значения для создания матрицы смежности -невзвешеного- ориентированого графа,");
                Console.WriteLine("в строчку через пробелы, после каждой строки матрицы нажимая -Enter-, ");


                int[,] Adj_Matrix = new int[Num, Num];   // создаем 2ух мерный массив - для хранения значений матрицы смежности
                string[] str;                             // создаем массив для хранения введенных пользователем значений из консоли
                for (int i = 0; i < Num; i++)
                {
                    str = (Console.ReadLine()).Split(' '); // заполняем массив символов введенных пользователем в строке разделенной пробелами
                    for (int j = 0; j < Num; j++)
                    {
                        Adj_Matrix[i, j] = Convert.ToInt32(str[j]);
                    }
                }

                for (int i = 0; i < Num; ++i) // создание "списка" смежности по исх. матрице смежности (для каждого узла перечисляем соседние узлы (с учетом направлений))
                {
                    for (int j = 0; j < Num; ++j)
                    {
                        if (Adj_Matrix[i, j] == 1) // если 0 - пропускаем
                              demo.AddV(i, j); // добавление узла j в список смежности узла i 
                    }
                }

                Console.WriteLine("Введите через пробел номера двух узлов маршрут между которыми вы хотите найти:");
                string[] str1;
                str1 = (Console.ReadLine()).Split(' ');

                demo.PrintPath(Convert.ToInt32(str1[0]), Convert.ToInt32(str1[1])); // вызов метода PrintPath для нахождения пути между передаными узлами с помощью BFS
                Console.ReadKey();
            }


            void graph_auto()
            {
                int[,] Adj_Matrix = new int[Num, Num];

                Random rnd = new Random();
                for (int i = 0; i < Num; i++) // создание рандомной матрицы смежности
                {
                    for (int j = 0; j < Num; j++)
                    {
                        Adj_Matrix[i, j] = rnd.Next(0, 2); // числа 0..1
                    }
                }

                for (int i = 0; i < Num; ++i)  // создание "списка" смежности по исх. матрице смежности (для каждого узла перечисляем соседние узлы (с учетом направлений))
                {
                    for (int j = 0; j < Num; ++j)
                    {
                        if (Adj_Matrix[i, j] == 1)
                              demo.AddV(i, j); // добавление узла j в список смежности узла i 
                    }
                }

                Console.WriteLine("Полученная матрица смежности:"); // распечатка полученой чатрицы смежности
                for (int i = 0; i < Num; ++i)
                {
                    for (int j = 0; j < Num; ++j)
                    {
                        Console.Write(Adj_Matrix[i, j] + " ");
                    }
                    Console.Write("\n");
                }

                Console.WriteLine("Введите через пробел номера двух узлов маршрут между которыми вы хотите найти:");
                string[] str1;
                str1 = (Console.ReadLine()).Split(' ');

                demo.PrintPath(Convert.ToInt32(str1[0]), Convert.ToInt32(str1[1])); // вызов метода PrintPath для нахождения пути между передаными узлами с помощью BFS
                Console.ReadKey();

            }
            
        }

        
    }

    
}
